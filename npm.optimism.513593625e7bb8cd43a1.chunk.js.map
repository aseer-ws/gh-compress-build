{"version":3,"sources":["webpack://react-template/./node_modules/optimism/lib/bundle.cjs.js"],"names":["Object","defineProperty","exports","value","context","defaultDispose","Cache","max","dispose","Infinity","this","map","Map","newest","oldest","prototype","has","key","get","entry","getEntry","older","newer","set","clean","size","delete","parentEntrySlot","Slot","reusableEmptyArray","emptySetPool","assert","condition","optionalMessage","Error","valueGet","length","Entry","fn","args","parents","Set","childValues","dirtyChildren","dirty","recomputing","count","recompute","child","parent","getValue","add","mightBeDirty","reportDirtyChild","reportCleanChild","rememberParent","maybeReportOrphan","originalChildren","forgetChildren","withValue","recomputeNewValue","subscribe","maybeUnsubscribe","unsubscribe","apply","e","setDirty","maybeSubscribe","reportClean","setClean","forEach","reallyRecompute","reportDirty","_this","forgetChild","pop","a","b","len","childValue","slice","removeDirtyChild","dc","push","reportOrphan","children","_value","KeyTrie","weakness","lookup","array","_i","arguments","lookupArray","node","getChildTrie","data","create","isObjRef","weak","WeakMap","strong","keyTrie","defaultMakeCacheKey","caches","enumerable","asyncFromGen","bind","noContext","setTimeout","wrap","originalFunction","options","cache","Math","pow","disposable","makeCacheKey","optimistic","hasValue","Array","call","clear"],"mappings":"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","file":"npm.optimism.513593625e7bb8cd43a1.chunk.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar context = require('@wry/context');\n\nfunction defaultDispose() { }\r\nvar Cache = /** @class */ (function () {\r\n    function Cache(max, dispose) {\r\n        if (max === void 0) { max = Infinity; }\r\n        if (dispose === void 0) { dispose = defaultDispose; }\r\n        this.max = max;\r\n        this.dispose = dispose;\r\n        this.map = new Map();\r\n        this.newest = null;\r\n        this.oldest = null;\r\n    }\r\n    Cache.prototype.has = function (key) {\r\n        return this.map.has(key);\r\n    };\r\n    Cache.prototype.get = function (key) {\r\n        var entry = this.getEntry(key);\r\n        return entry && entry.value;\r\n    };\r\n    Cache.prototype.getEntry = function (key) {\r\n        var entry = this.map.get(key);\r\n        if (entry && entry !== this.newest) {\r\n            var older = entry.older, newer = entry.newer;\r\n            if (newer) {\r\n                newer.older = older;\r\n            }\r\n            if (older) {\r\n                older.newer = newer;\r\n            }\r\n            entry.older = this.newest;\r\n            entry.older.newer = entry;\r\n            entry.newer = null;\r\n            this.newest = entry;\r\n            if (entry === this.oldest) {\r\n                this.oldest = newer;\r\n            }\r\n        }\r\n        return entry;\r\n    };\r\n    Cache.prototype.set = function (key, value) {\r\n        var entry = this.getEntry(key);\r\n        if (entry) {\r\n            return entry.value = value;\r\n        }\r\n        entry = {\r\n            key: key,\r\n            value: value,\r\n            newer: null,\r\n            older: this.newest\r\n        };\r\n        if (this.newest) {\r\n            this.newest.newer = entry;\r\n        }\r\n        this.newest = entry;\r\n        this.oldest = this.oldest || entry;\r\n        this.map.set(key, entry);\r\n        return entry.value;\r\n    };\r\n    Cache.prototype.clean = function () {\r\n        while (this.oldest && this.map.size > this.max) {\r\n            this.delete(this.oldest.key);\r\n        }\r\n    };\r\n    Cache.prototype.delete = function (key) {\r\n        var entry = this.map.get(key);\r\n        if (entry) {\r\n            if (entry === this.newest) {\r\n                this.newest = entry.older;\r\n            }\r\n            if (entry === this.oldest) {\r\n                this.oldest = entry.newer;\r\n            }\r\n            if (entry.newer) {\r\n                entry.newer.older = entry.older;\r\n            }\r\n            if (entry.older) {\r\n                entry.older.newer = entry.newer;\r\n            }\r\n            this.map.delete(key);\r\n            this.dispose(entry.value, key);\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    return Cache;\r\n}());\n\nvar parentEntrySlot = new context.Slot();\n\nvar reusableEmptyArray = [];\r\nvar emptySetPool = [];\r\nvar POOL_TARGET_SIZE = 100;\r\n// Since this package might be used browsers, we should avoid using the\r\n// Node built-in assert module.\r\nfunction assert(condition, optionalMessage) {\r\n    if (!condition) {\r\n        throw new Error(optionalMessage || \"assertion failure\");\r\n    }\r\n}\r\nfunction valueIs(a, b) {\r\n    var len = a.length;\r\n    return (\r\n    // Unknown values are not equal to each other.\r\n    len > 0 &&\r\n        // Both values must be ordinary (or both exceptional) to be equal.\r\n        len === b.length &&\r\n        // The underlying value or exception must be the same.\r\n        a[len - 1] === b[len - 1]);\r\n}\r\nfunction valueGet(value) {\r\n    switch (value.length) {\r\n        case 0: throw new Error(\"unknown value\");\r\n        case 1: return value[0];\r\n        case 2: throw value[1];\r\n    }\r\n}\r\nfunction valueCopy(value) {\r\n    return value.slice(0);\r\n}\r\nvar Entry = /** @class */ (function () {\r\n    function Entry(fn, args) {\r\n        this.fn = fn;\r\n        this.args = args;\r\n        this.parents = new Set();\r\n        this.childValues = new Map();\r\n        // When this Entry has children that are dirty, this property becomes\r\n        // a Set containing other Entry objects, borrowed from emptySetPool.\r\n        // When the set becomes empty, it gets recycled back to emptySetPool.\r\n        this.dirtyChildren = null;\r\n        this.dirty = true;\r\n        this.recomputing = false;\r\n        this.value = [];\r\n        ++Entry.count;\r\n    }\r\n    // This is the most important method of the Entry API, because it\r\n    // determines whether the cached this.value can be returned immediately,\r\n    // or must be recomputed. The overall performance of the caching system\r\n    // depends on the truth of the following observations: (1) this.dirty is\r\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\r\n    // (3) valueGet(this.value) is usually returned without recomputation.\r\n    Entry.prototype.recompute = function () {\r\n        assert(!this.recomputing, \"already recomputing\");\r\n        if (!rememberParent(this) && maybeReportOrphan(this)) {\r\n            // The recipient of the entry.reportOrphan callback decided to dispose\r\n            // of this orphan entry by calling entry.dispose(), so we don't need to\r\n            // (and should not) proceed with the recomputation.\r\n            return void 0;\r\n        }\r\n        return mightBeDirty(this)\r\n            ? reallyRecompute(this)\r\n            : valueGet(this.value);\r\n    };\r\n    Entry.prototype.setDirty = function () {\r\n        if (this.dirty)\r\n            return;\r\n        this.dirty = true;\r\n        this.value.length = 0;\r\n        reportDirty(this);\r\n        // We can go ahead and unsubscribe here, since any further dirty\r\n        // notifications we receive will be redundant, and unsubscribing may\r\n        // free up some resources, e.g. file watchers.\r\n        maybeUnsubscribe(this);\r\n    };\r\n    Entry.prototype.dispose = function () {\r\n        var _this = this;\r\n        forgetChildren(this).forEach(maybeReportOrphan);\r\n        maybeUnsubscribe(this);\r\n        // Because this entry has been kicked out of the cache (in index.js),\r\n        // we've lost the ability to find out if/when this entry becomes dirty,\r\n        // whether that happens through a subscription, because of a direct call\r\n        // to entry.setDirty(), or because one of its children becomes dirty.\r\n        // Because of this loss of future information, we have to assume the\r\n        // worst (that this entry might have become dirty very soon), so we must\r\n        // immediately mark this entry's parents as dirty. Normally we could\r\n        // just call entry.setDirty() rather than calling parent.setDirty() for\r\n        // each parent, but that would leave this entry in parent.childValues\r\n        // and parent.dirtyChildren, which would prevent the child from being\r\n        // truly forgotten.\r\n        this.parents.forEach(function (parent) {\r\n            parent.setDirty();\r\n            forgetChild(parent, _this);\r\n        });\r\n    };\r\n    Entry.count = 0;\r\n    return Entry;\r\n}());\r\nfunction rememberParent(child) {\r\n    var parent = parentEntrySlot.getValue();\r\n    if (parent) {\r\n        child.parents.add(parent);\r\n        if (!parent.childValues.has(child)) {\r\n            parent.childValues.set(child, []);\r\n        }\r\n        if (mightBeDirty(child)) {\r\n            reportDirtyChild(parent, child);\r\n        }\r\n        else {\r\n            reportCleanChild(parent, child);\r\n        }\r\n        return parent;\r\n    }\r\n}\r\nfunction reallyRecompute(entry) {\r\n    // Since this recomputation is likely to re-remember some of this\r\n    // entry's children, we forget our children here but do not call\r\n    // maybeReportOrphan until after the recomputation finishes.\r\n    var originalChildren = forgetChildren(entry);\r\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\r\n    parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);\r\n    if (maybeSubscribe(entry)) {\r\n        // If we successfully recomputed entry.value and did not fail to\r\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\r\n        setClean(entry);\r\n    }\r\n    // Now that we've had a chance to re-remember any children that were\r\n    // involved in the recomputation, we can safely report any orphan\r\n    // children that remain.\r\n    originalChildren.forEach(maybeReportOrphan);\r\n    return valueGet(entry.value);\r\n}\r\nfunction recomputeNewValue(entry) {\r\n    entry.recomputing = true;\r\n    // Set entry.value as unknown.\r\n    entry.value.length = 0;\r\n    try {\r\n        // If entry.fn succeeds, entry.value will become a normal Value.\r\n        entry.value[0] = entry.fn.apply(null, entry.args);\r\n    }\r\n    catch (e) {\r\n        // If entry.fn throws, entry.value will become exceptional.\r\n        entry.value[1] = e;\r\n    }\r\n    // Either way, this line is always reached.\r\n    entry.recomputing = false;\r\n}\r\nfunction mightBeDirty(entry) {\r\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\r\n}\r\nfunction setClean(entry) {\r\n    entry.dirty = false;\r\n    if (mightBeDirty(entry)) {\r\n        // This Entry may still have dirty children, in which case we can't\r\n        // let our parents know we're clean just yet.\r\n        return;\r\n    }\r\n    reportClean(entry);\r\n}\r\nfunction reportDirty(child) {\r\n    child.parents.forEach(function (parent) { return reportDirtyChild(parent, child); });\r\n}\r\nfunction reportClean(child) {\r\n    child.parents.forEach(function (parent) { return reportCleanChild(parent, child); });\r\n}\r\n// Let a parent Entry know that one of its children may be dirty.\r\nfunction reportDirtyChild(parent, child) {\r\n    // Must have called rememberParent(child) before calling\r\n    // reportDirtyChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(mightBeDirty(child));\r\n    if (!parent.dirtyChildren) {\r\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\r\n    }\r\n    else if (parent.dirtyChildren.has(child)) {\r\n        // If we already know this child is dirty, then we must have already\r\n        // informed our own parents that we are dirty, so we can terminate\r\n        // the recursion early.\r\n        return;\r\n    }\r\n    parent.dirtyChildren.add(child);\r\n    reportDirty(parent);\r\n}\r\n// Let a parent Entry know that one of its children is no longer dirty.\r\nfunction reportCleanChild(parent, child) {\r\n    // Must have called rememberChild(child) before calling\r\n    // reportCleanChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(!mightBeDirty(child));\r\n    var childValue = parent.childValues.get(child);\r\n    if (childValue.length === 0) {\r\n        parent.childValues.set(child, valueCopy(child.value));\r\n    }\r\n    else if (!valueIs(childValue, child.value)) {\r\n        parent.setDirty();\r\n    }\r\n    removeDirtyChild(parent, child);\r\n    if (mightBeDirty(parent)) {\r\n        return;\r\n    }\r\n    reportClean(parent);\r\n}\r\nfunction removeDirtyChild(parent, child) {\r\n    var dc = parent.dirtyChildren;\r\n    if (dc) {\r\n        dc.delete(child);\r\n        if (dc.size === 0) {\r\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\r\n                emptySetPool.push(dc);\r\n            }\r\n            parent.dirtyChildren = null;\r\n        }\r\n    }\r\n}\r\n// If the given entry has a reportOrphan method, and no remaining parents,\r\n// call entry.reportOrphan and return true iff it returns true. The\r\n// reportOrphan function should return true to indicate entry.dispose()\r\n// has been called, and the entry has been removed from any other caches\r\n// (see index.js for the only current example).\r\nfunction maybeReportOrphan(entry) {\r\n    return entry.parents.size === 0 &&\r\n        typeof entry.reportOrphan === \"function\" &&\r\n        entry.reportOrphan() === true;\r\n}\r\n// Removes all children from this entry and returns an array of the\r\n// removed children.\r\nfunction forgetChildren(parent) {\r\n    var children = reusableEmptyArray;\r\n    if (parent.childValues.size > 0) {\r\n        children = [];\r\n        parent.childValues.forEach(function (_value, child) {\r\n            forgetChild(parent, child);\r\n            children.push(child);\r\n        });\r\n    }\r\n    // After we forget all our children, this.dirtyChildren must be empty\r\n    // and therefore must have been reset to null.\r\n    assert(parent.dirtyChildren === null);\r\n    return children;\r\n}\r\nfunction forgetChild(parent, child) {\r\n    child.parents.delete(parent);\r\n    parent.childValues.delete(child);\r\n    removeDirtyChild(parent, child);\r\n}\r\nfunction maybeSubscribe(entry) {\r\n    if (typeof entry.subscribe === \"function\") {\r\n        try {\r\n            maybeUnsubscribe(entry); // Prevent double subscriptions.\r\n            entry.unsubscribe = entry.subscribe.apply(null, entry.args);\r\n        }\r\n        catch (e) {\r\n            // If this Entry has a subscribe function and it threw an exception\r\n            // (or an unsubscribe function it previously returned now throws),\r\n            // return false to indicate that we were not able to subscribe (or\r\n            // unsubscribe), and this Entry should remain dirty.\r\n            entry.setDirty();\r\n            return false;\r\n        }\r\n    }\r\n    // Returning true indicates either that there was no entry.subscribe\r\n    // function or that it succeeded.\r\n    return true;\r\n}\r\nfunction maybeUnsubscribe(entry) {\r\n    var unsubscribe = entry.unsubscribe;\r\n    if (typeof unsubscribe === \"function\") {\r\n        entry.unsubscribe = void 0;\r\n        unsubscribe();\r\n    }\r\n}\n\n// A trie data structure that holds object keys weakly, yet can also hold\r\n// non-object keys, unlike the native `WeakMap`.\r\nvar KeyTrie = /** @class */ (function () {\r\n    function KeyTrie(weakness) {\r\n        this.weakness = weakness;\r\n    }\r\n    KeyTrie.prototype.lookup = function () {\r\n        var array = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            array[_i] = arguments[_i];\r\n        }\r\n        return this.lookupArray(array);\r\n    };\r\n    KeyTrie.prototype.lookupArray = function (array) {\r\n        var node = this;\r\n        array.forEach(function (key) { return node = node.getChildTrie(key); });\r\n        return node.data || (node.data = Object.create(null));\r\n    };\r\n    KeyTrie.prototype.getChildTrie = function (key) {\r\n        var map = this.weakness && isObjRef(key)\r\n            ? this.weak || (this.weak = new WeakMap())\r\n            : this.strong || (this.strong = new Map());\r\n        var child = map.get(key);\r\n        if (!child)\r\n            map.set(key, child = new KeyTrie(this.weakness));\r\n        return child;\r\n    };\r\n    return KeyTrie;\r\n}());\r\nfunction isObjRef(value) {\r\n    switch (typeof value) {\r\n        case \"object\":\r\n            if (value === null)\r\n                break;\r\n        // Fall through to return true...\r\n        case \"function\":\r\n            return true;\r\n    }\r\n    return false;\r\n}\n\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\r\n// a unique object for any shallow-identical list of arguments. If you need\r\n// to implement a custom makeCacheKey function, you may find it helpful to\r\n// delegate the final work to defaultMakeCacheKey, which is why we export it\r\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\r\n// does not support WeakMap, or you have the ability to return a string key.\r\n// In those cases, just write your own custom makeCacheKey functions.\r\nvar keyTrie = new KeyTrie(typeof WeakMap === \"function\");\r\nfunction defaultMakeCacheKey() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    return keyTrie.lookupArray(args);\r\n}\r\nvar caches = new Set();\r\nfunction wrap(originalFunction, options) {\r\n    if (options === void 0) { options = Object.create(null); }\r\n    var cache = new Cache(options.max || Math.pow(2, 16), function (entry) { return entry.dispose(); });\r\n    var disposable = !!options.disposable;\r\n    var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;\r\n    function optimistic() {\r\n        if (disposable && !parentEntrySlot.hasValue()) {\r\n            // If there's no current parent computation, and this wrapped\r\n            // function is disposable (meaning we don't care about entry.value,\r\n            // just dependency tracking), then we can short-cut everything else\r\n            // in this function, because entry.recompute() is going to recycle\r\n            // the entry object without recomputing anything, anyway.\r\n            return void 0;\r\n        }\r\n        var key = makeCacheKey.apply(null, arguments);\r\n        if (key === void 0) {\r\n            return originalFunction.apply(null, arguments);\r\n        }\r\n        var args = Array.prototype.slice.call(arguments);\r\n        var entry = cache.get(key);\r\n        if (entry) {\r\n            entry.args = args;\r\n        }\r\n        else {\r\n            entry = new Entry(originalFunction, args);\r\n            cache.set(key, entry);\r\n            entry.subscribe = options.subscribe;\r\n            if (disposable) {\r\n                entry.reportOrphan = function () { return cache.delete(key); };\r\n            }\r\n        }\r\n        var value = entry.recompute();\r\n        // Move this entry to the front of the least-recently used queue,\r\n        // since we just finished computing its value.\r\n        cache.set(key, entry);\r\n        caches.add(cache);\r\n        // Clean up any excess entries in the cache, but only if there is no\r\n        // active parent entry, meaning we're not in the middle of a larger\r\n        // computation that might be flummoxed by the cleaning.\r\n        if (!parentEntrySlot.hasValue()) {\r\n            caches.forEach(function (cache) { return cache.clean(); });\r\n            caches.clear();\r\n        }\r\n        // If options.disposable is truthy, the caller of wrap is telling us\r\n        // they don't care about the result of entry.recompute(), so we should\r\n        // avoid returning the value, so it won't be accidentally used.\r\n        return disposable ? void 0 : value;\r\n    }\r\n    optimistic.dirty = function () {\r\n        var key = makeCacheKey.apply(null, arguments);\r\n        var child = key !== void 0 && cache.get(key);\r\n        if (child) {\r\n            child.setDirty();\r\n        }\r\n    };\r\n    return optimistic;\r\n}\n\nObject.defineProperty(exports, 'asyncFromGen', {\n  enumerable: true,\n  get: function () {\n    return context.asyncFromGen;\n  }\n});\nObject.defineProperty(exports, 'bindContext', {\n  enumerable: true,\n  get: function () {\n    return context.bind;\n  }\n});\nObject.defineProperty(exports, 'noContext', {\n  enumerable: true,\n  get: function () {\n    return context.noContext;\n  }\n});\nObject.defineProperty(exports, 'setTimeout', {\n  enumerable: true,\n  get: function () {\n    return context.setTimeout;\n  }\n});\nexports.KeyTrie = KeyTrie;\nexports.defaultMakeCacheKey = defaultMakeCacheKey;\nexports.wrap = wrap;\n//# sourceMappingURL=bundle.cjs.js.map\n"],"sourceRoot":""}